<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Beebee Renderer - Animation Fixed</title>
    <script src="https://cdn.jsdelivr.net/gh/jnordberg/gif.js/dist/gif.js"></script>
    <style>
        body { background: #1a1a1a; color: white; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; margin: 0; padding: 10px; }
        h2 { margin: 10px 0; font-size: 1.4em; color: #eee; text-align: center; }
        .app-layout { display: flex; flex-direction: column; gap: 15px; background: #222; padding: 15px; border-radius: 12px; width: 95%; max-width: 1200px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        .canvas-container { flex: 1.5; position: relative; display: flex; justify-content: center; }
        canvas { background: #333; border-radius: 8px; width: 100%; max-width: 720px; height: auto; border: 1px solid #444; }
        .controls-panel { flex: 1; display: flex; flex-direction: column; gap: 8px; }
        .grid-controls { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .full-width { grid-column: span 2; }
        @media (min-width: 900px) { .app-layout { flex-direction: row; align-items: flex-start; padding: 25px; } .controls-panel { max-height: 85vh; overflow-y: auto; padding-right: 5px; } }
        select, button { padding: 12px; background: #3d3d3d; color: white; border: 1px solid #555; border-radius: 8px; font-size: 14px; outline: none; cursor: pointer; }
        select:disabled { opacity: 0.5; cursor: not-allowed; background: #222; }
        .active { background: #e74c3c !important; font-weight: bold; }
        .vibrate-btn.on { background: #9b59b6 !important; }
        .flip-btn.on { background: #3498db !important; }
        .cone-btn.on { background: #3498db !important; border-color: #5dade2; }
        .random-btn { background: #f39c12; color: #1a1a1a; font-weight: bold; }
        .download-btn { background: #27ae60; border: none; font-weight: bold; }
        .unlock-btn { background: #444; color: #aaa; font-size: 11px; margin-top: 10px; border-style: dashed; }
        .unlock-btn.enabled { background: #c0392b !important; color: white; border-style: solid; box-shadow: 0 0 10px rgba(192, 57, 43, 0.5); }
        .reset-btn { background: transparent; border: 1px solid #444; color: #666; font-size: 10px; margin-top: 5px; padding: 5px; }
        #status { font-size: 0.9em; color: #f1c40f; text-align: center; display: none; padding: 10px; font-weight: bold; }
        label { font-size: 0.7em; color: #888; margin-top: 5px; font-weight: bold; text-transform: uppercase; }
        hr { border: 0; border-top: 1px solid #444; width: 100%; margin: 10px 0; }
    </style>
</head>
<body>

    <h2>Beebee Renderer</h2>

    <div class="app-layout">
        <div class="canvas-container">
            <canvas id="beebeeCanvas" width="720" height="500"></canvas>
            <div id="status">GENERATING GIF... PLEASE WAIT</div>
        </div>
        
        <div class="controls-panel">
            <label>Character Version</label>
            <select id="actSelect">
                <option value="act1">Act 1: The Encounter</option>
                <option value="act2">Act 2: The Battle</option>
                <option value="act3">Act 3: The Fight</option>
                <option value="act4_convo">Act 4: Conversation</option>
            </select>

            <div class="grid-controls">
                <button id="randomBtn" class="random-btn">Randomize</button>
                <button id="vibeToggle" class="vibrate-btn">Vibration: OFF</button>
                <button id="flipToggle" class="flip-btn">Flip: OFF</button>
                <button id="coneToggle" class="cone-btn">Cone: OFF</button>
            </div>

            <hr>

            <label>Special Poses (*)</label>
            <select id="specialSelect"></select>

            <div class="grid-controls">
                <div style="display:flex; flex-direction:column;">
                    <label>Body</label>
                    <select id="bodySelect" style="width:100%"></select>
                </div>
                <div style="display:flex; flex-direction:column;">
                    <label id="eyesLabel">Eyes</label>
                    <select id="eyesSelect" style="width:100%"></select>
                </div>
            </div>
            
            <label>Mouth</label>
            <select id="mouthSelect"></select>

            <hr>
            
            <button id="loopBtn" class="full-width">Start Loop</button>
            <button id="mainDownloadBtn" class="download-btn">Download Image</button>
            <button id="unlockBtn" class="unlock-btn">Enable Unrestricted Mode</button>
            <button id="resetBtn" class="reset-btn">Reset All to Defaults</button>
        </div>
    </div>

<script>
const acts = {
    act1: { src: 'act1_beebee.png', grid: { width: 4 }, anchor: { x: 273, y: 200 }, frame: { w: 720, h: 500 }, frames: ["body_normal","body_fear","body_point_crotch","body_point_heart","body_sing","mouth_normal","mouth_normal_talk","mouth_small","mouth_small_talk","mouth_small_lock","eyes_normal","eyes_normal_right","eyes_uncertain","eyes_uncertain_right","eyes_narrow","eyes_narrow_eyebrow","eyes_fear","eyes_pretty","eyes_wat","eyes_wat_2","body_panic*","body_panic_2*","body_scream_anger*","body_scream_anger_2*","body_scream*","body_scream_2*","body_flail*","body_flail2*","body_flail3*","body_flail4*","mouth_smile","mouth_smile_talk","mouth_smile_lock","eyes_smile","eyes_look","eyes_look_sad","eyes_look_sad_smile","eyes_pained1","eyes_pained2","mouth_shut","eyes_anger","body_meta*","body_laugh*","body_pride_talk*","body_pride*","body_squeeze_talk*","body_squeeze*"], loops: [{ trigger: "panic*", sequence: ["body_panic*", "body_panic_2*"], wait: 0.07 }, { trigger: "scream*", sequence: ["body_scream*", "body_scream_2*"], wait: 0.1 }] },
    act2: { src: 'battle_bb.png', grid: { width: 10 }, anchor: { x: 292.5, y: 249.4 }, frame: { w: 720, h: 500 }, frames: ["body_normal","body_two_up","body_chest","body_point","body_one_up","body_scream_a_1*","body_scream_a_2*","body_shocked*","mouth_small","mouth_small_talk","mouth_normal","mouth_normal_talk","mouth_smile","mouth_smile_talk","eyes_normal","eyes_normal_r","eyes_suspect","eyes_suspect_r","eyes_sad","eyes_sad_r","eyes_shock","eyes_happy","eyes_happy_r","eyes_closed","eyes_judge","body_judge_1","body_judge_2","body_scream_b_1*","body_scream_b_2*","body_scream_c_1*","body_scream_c_2*","body_cry_1*","body_cry_2*","body_cry_3*","body_cry_4","mouth_cry_talk","mouth_cry","eyes_cry","eyes_cry_2","body_cry_5*","body_cry_6","mouth_right","mouth_right_talk","eyes_cry_r_1","eyes_cry_r_2","eyes_cry_r_3","eyes_cry_r_4","mouth_blank","eyes_blank","eyes_asdf","eyes_angry","eyes_sad_2","eyes_wat","body_attacked*","body_frazzled","mouth_frazzled_talk","mouth_frazzled","eyes_frazzled","body_panicked","mouth_panicked","mouth_panicked_talk","eyes_panicked","body_special_a*","body_special_b_1*","body_special_b_2*","body_special_b_3*","body_special_c*","body_final_1*","body_final_2*","body_final_3*","body_final_4*","body_yell_1*","body_yell_2*","body_yell_angry_1*","body_yell_angry_2*"], loops: [{ trigger: "final*", sequence: ["body_final_1*", "body_final_2*", "body_final_3*", "body_final_4*"], wait: 0.05 }, { trigger: "scream_a*", sequence: ["body_scream_a_1*", "body_scream_a_2*"], wait: 0.1 }, { trigger: "scream_b*", sequence: ["body_scream_b_1*", "body_scream_b_2*"], wait: 0.1 }, { trigger: "scream_c*", sequence: ["body_scream_c_1*", "body_scream_c_2*"], wait: 0.1 }, { trigger: "cry*", sequence: ["body_cry_1*", "body_cry_2*", "body_cry_3*", "body_cry_5*"], wait: 0.15 }] },
    act3: { src: 'fight_bb.png', grid: { width: 8 }, anchor: { x: 270, y: 223 }, frame: { w: 720, h: 500 }, frames: ["body_normal_1","body_normal_2","body_normal_3","body_normal_4","mouth_sorry","mouth_sorry_talk","eyes_sorry_down","eyes_sorry","eyes_sorry_up","mouth_normal","mouth_normal_talk","eyes_oh_crap","eyes_start","eyes_normal","eyes_angry","eyes_sad","mouth_ignore","mouth_ignore_talk","eyes_ignore","eyes_ignore_oh_crap","body_attacked*","body_dead*","body_special_attack*"], loops: [] },
    act4_convo: { 
        src: 'bb_convo.png', 
        grid: { width: 8 }, 
        anchor: { x: 171, y: 242 }, 
        frame: { w: 500, h: 500 }, 
        layers: ["coneb", "body", "mouth", "eyes", "cone"], 
        frames: [
            "body_normal", "body_chest", "body_two_up", "body_one_up", "body_paw", "cone_normal", "coneb_normal", "mouth_normal",
            "mouth_normal_talk", "mouth_narrow", "mouth_narrow_talk", "mouth_smile", "mouth_smile_talk", "mouth_scream", "mouth_scream_talk", "cone_scream",
            "coneb_scream", "eyes_normal", "eyes_normal_r", "eyes_normal_u", "eyes_normal_d", "eyes_look_down", "eyes_scream", "eyes_scream_sad",
            "eyes_super_sad", "eyes_closed", "eyes_closed_annoyed", "eyes_sexy", "eyes_smile", "eyes_smile_r", "eyes_smile_u", "eyes_smile_d",
            "eyes_angry", "eyes_angry_r", "eyes_angry_u", "eyes_angry_d", "eyes_surprise", "eyes_surprise_r", "eyes_surprise_u", "eyes_surprise_d",
            "eyes_annoyed", "eyes_annoyed_r", "eyes_annoyed_u", "eyes_annoyed_d", "eyes_sad", "eyes_sad_r", "eyes_sad_u", "eyes_sad_d",
            "eyes_suspect", "eyes_suspect_r", "body_karate_1*", "body_karate_2*", "cone_karate", "coneb_karate", "body_yap_1*", "body_yap_2*",
            "body_yap_3*", "body_yap_4*", "cone_yap_1", "cone_yap_2", "cone_yap_3", "cone_yap_4", "eyes_blank", "mouth_blank", "coneb_blank"
        ], 
        loops: [
            { trigger: "yap*", sequence: ["body_yap_1*", "body_yap_2*", "body_yap_3*", "body_yap_4*"], wait: 1/24 }, 
            { trigger: "karate*", sequence: ["body_karate_1*", "body_karate_2*"], wait: 0.25 }
        ] 
    }
};

const canvas = document.getElementById('beebeeCanvas'), ctx = canvas.getContext('2d');
let currentAct = 'act1', ticker = 0, lastTime = 0, animTimer = 0, animIndex = 0, isLooping = false, vibrateOn = false, isFlipped = false, coneOn = false, unrestricted = false;
const images = {}; Object.keys(acts).forEach(k => { images[k] = new Image(); images[k].src = acts[k].src; });

const bSel = document.getElementById('bodySelect'), mSel = document.getElementById('mouthSelect'), eSel = document.getElementById('eyesSelect'), sSel = document.getElementById('specialSelect'), aSel = document.getElementById('actSelect'), lBtn = document.getElementById('loopBtn'), rBtn = document.getElementById('randomBtn'), vBtn = document.getElementById('vibeToggle'), fBtn = document.getElementById('flipToggle'), cBtn = document.getElementById('coneToggle'), dBtn = document.getElementById('mainDownloadBtn'), uBtn = document.getElementById('unlockBtn'), reBtn = document.getElementById('resetBtn'), statusTxt = document.getElementById('status');

function saveState() {
    const state = { act: currentAct, body: bSel.value, mouth: mSel.value, eyes: eSel.value, spec: sSel.value, vibe: vibrateOn, flip: isFlipped, cone: coneOn, unres: unrestricted, looping: isLooping };
    localStorage.setItem('bb_renderer_state', JSON.stringify(state));
}

function loadState() {
    const saved = localStorage.getItem('bb_renderer_state');
    if (!saved) return false;
    const s = JSON.parse(saved);
    currentAct = s.act; aSel.value = s.act;
    populateSelects(false); 
    bSel.value = s.body; mSel.value = s.mouth; eSel.value = s.eyes; sSel.value = s.spec;
    vibrateOn = s.vibe; isFlipped = s.flip; coneOn = s.cone; unrestricted = s.unres; isLooping = s.looping;
    updateUI();
    return true;
}

function populateSelects(resetDefaults = true) {
    [bSel, mSel, eSel, sSel].forEach(s => s.innerHTML = '');
    const n = document.createElement('option'); n.value = 'none'; n.textContent = '-- Manual Mix --'; sSel.appendChild(n);
    acts[currentAct].frames.forEach(name => {
        if (name.includes("blank")) return;
        const o = document.createElement('option'); o.value = name; o.textContent = name;
        if (name.includes('*')) sSel.appendChild(o); 
        else if (name.startsWith('body')) bSel.appendChild(o); 
        else if (name.startsWith('mouth')) mSel.appendChild(o); 
        else if (name.startsWith('eyes')) eSel.appendChild(o);
    });
    if(resetDefaults) updateUI();
}

function updateUI() {
    const isSpecial = sSel.value !== 'none';
    const bodyVal = bSel.value || "";
    const mouthVal = mSel.value || "";
    const eyesVal = eSel.value || "";
    const isAct2 = currentAct === 'act2';
    const isAct4 = currentAct === 'act4_convo';

    const isRight = (v) => v.includes('_right') || v.includes('_r') || v.endsWith('_r');
    const isHardCry = (v) => v.includes('cry') && !isRight(v);
    const isJudge = (v) => v.includes('judge');

    bSel.disabled = isSpecial; mSel.disabled = isSpecial; eSel.disabled = isSpecial;
    [bSel, mSel, eSel].forEach(s => Array.from(s.options).forEach(o => o.disabled = false));

    if (!isSpecial && !unrestricted) {
        if (isAct2 && (isJudge(bodyVal) || isJudge(eyesVal))) { 
            if (!isJudge(bodyVal)) bSel.value = 'body_judge_1';
            if (!isJudge(eyesVal)) eSel.value = 'eyes_judge';
            if (isHardCry(mouthVal) || isRight(mouthVal)) mSel.value = 'mouth_normal';
            eSel.disabled = true;
            Array.from(mSel.options).forEach(o => { if(isHardCry(o.value) || isRight(o.value)) o.disabled = true; });
            Array.from(bSel.options).forEach(o => { if(isHardCry(o.value)) o.disabled = true; });
        } 
        else if (isAct2 && (isHardCry(bodyVal) || isHardCry(mouthVal) || isHardCry(eyesVal))) {
            if(!isHardCry(bodyVal)) bSel.value = 'body_cry_6';
            if(!isHardCry(eSel.value)) eSel.value = 'eyes_cry';
            if(!isHardCry(mSel.value)) mSel.value = 'mouth_cry';
            [eSel, mSel, bSel].forEach(s => Array.from(s.options).forEach(o => o.disabled = !isHardCry(o.value)));
        } 
        else if (isRight(mouthVal)) {
            if (!isRight(eyesVal)) eSel.value = 'eyes_normal_r';
            Array.from(eSel.options).forEach(o => o.disabled = !isRight(o.value));
        }
        else {
            Array.from(eSel.options).forEach(o => o.disabled = (isJudge(o.value) || isHardCry(o.value)));
            Array.from(mSel.options).forEach(o => o.disabled = (isHardCry(o.value) || (isAct2 && isRight(o.value))));
            Array.from(bSel.options).forEach(o => o.disabled = isHardCry(o.value));
        }
    }

    cBtn.style.display = isAct4 ? 'block' : 'none';
    
    // LOOP BUTTON LOGIC: Always show if vibrate is on OR pose is special
    const loopData = acts[currentAct].loops.find(l => sSel.value.includes(l.trigger.replace('*','')));
    lBtn.style.display = (loopData || vibrateOn) ? 'block' : 'none';
    lBtn.textContent = isLooping ? "Stop Loop" : "Start Loop";
    lBtn.className = isLooping ? "full-width active" : "full-width";
    
    vBtn.textContent = vibrateOn ? "Vibration: ON" : "Vibration: OFF"; vBtn.className = vibrateOn ? "vibrate-btn on" : "vibrate-btn";
    fBtn.textContent = isFlipped ? "Flip: ON" : "Flip: OFF"; fBtn.className = isFlipped ? "flip-btn on" : "flip-btn";
    cBtn.className = coneOn ? "cone-btn on" : "cone-btn";
    uBtn.textContent = unrestricted ? "Unrestricted: ON" : "Enable Unrestricted Mode";
    uBtn.className = unrestricted ? "unlock-btn enabled" : "unlock-btn";
    dBtn.textContent = (vibrateOn || isLooping) ? "Download GIF" : "Download PNG";
    saveState();
}

uBtn.onclick = () => {
    if (!unrestricted) {
        if (window.confirm("WARNING: Unrestricted Mode disables all orientation and set locks. Assets may overlap or look broken. Proceed?")) unrestricted = true;
    } else { unrestricted = false; }
    updateUI();
};

reBtn.onclick = () => {
    if (window.confirm("Reset all settings and clear saved data?")) {
        localStorage.removeItem('bb_renderer_state');
        location.reload();
    }
};

rBtn.onclick = () => {
    stopLoop(); 
    sSel.value = 'none';
    [bSel, mSel, eSel].forEach(s => Array.from(s.options).forEach(o => o.disabled = false));
    [bSel, mSel, eSel].forEach(s => { 
        s.value = s.options[Math.floor(Math.random() * s.options.length)].value;
    });
    updateUI();
};

aSel.onchange = () => { currentAct = aSel.value; stopLoop(); populateSelects(); };
[sSel, bSel, mSel, eSel].forEach(el => el.onchange = () => { stopLoop(); updateUI(); });
vBtn.onclick = () => { vibrateOn = !vibrateOn; updateUI(); };
fBtn.onclick = () => { isFlipped = !isFlipped; updateUI(); };
cBtn.onclick = () => { coneOn = !coneOn; updateUI(); };
lBtn.onclick = () => { isLooping = !isLooping; updateUI(); };

function drawLayer(name) {
    const act = acts[currentAct]; const idx = act.frames.indexOf(name); if (idx === -1) return;
    const col = idx % act.grid.width, row = Math.floor(idx / act.grid.width);
    const sw = act.frame.w, sh = act.frame.h;
    ctx.drawImage(images[currentAct], col*sw, row*sh, sw, sh, -act.anchor.x, -act.anchor.y, sw, sh);
}

function mainLoop(time) {
    const delta = (time - lastTime) / 1000; lastTime = time; ticker += delta;
    ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.save();
    ctx.translate(canvas.width / 2, canvas.height / 2);
    if (isFlipped) ctx.scale(-1, 1);
    
    let frameToDraw = sSel.value;
    let currentAnimIndex = animIndex;
    const loop = acts[currentAct].loops.find(l => sSel.value.includes(l.trigger.replace('*','')));
    
    // Animation only happens if isLooping is TRUE
    if (loop && isLooping) { 
        animTimer += delta; 
        if (animTimer >= loop.wait) { animIndex = (animIndex + 1) % loop.sequence.length; animTimer = 0; } 
        frameToDraw = loop.sequence[animIndex];
        currentAnimIndex = animIndex;
    } else {
        animIndex = 0; // Reset to first frame if not looping
    }
    
    let squash = (vibrateOn && isLooping) ? 1 + Math.sin(ticker * Math.PI * 2 * 7) * 0.01 : 1;
    ctx.scale(1, squash);

    const layers = acts[currentAct].layers || ["body", "mouth", "eyes"];
    layers.forEach(l => {
        let activeFrame = (frameToDraw !== 'none') ? frameToDraw : null;
        if (l === "coneb" || l === "cone") {
            if (!coneOn) return;
            let type = "normal";
            let pose = activeFrame || bSel.value || "";
            if (pose.includes("yap")) type = "yap_" + (currentAnimIndex + 1);
            else if (pose.includes("karate")) type = "karate";
            else if (pose.includes("scream")) type = "scream";
            let suffix = (l === "coneb" && (type.startsWith("yap") || type === "normal")) ? "blank" : type;
            drawLayer(l + "_" + suffix);
        } 
        else if (l === "body") drawLayer(activeFrame || bSel.value);
        else if (l === "mouth") drawLayer(activeFrame ? "mouth_blank" : mSel.value);
        else if (l === "eyes") drawLayer(activeFrame ? "eyes_blank" : eSel.value);
    });
    ctx.restore(); requestAnimationFrame(mainLoop);
}

function stopLoop() { isLooping = false; animTimer = 0; animIndex = 0; updateUI(); }

dBtn.onclick = () => {
    if (dBtn.textContent === "Download PNG") {
        const link = document.createElement('a'); link.download = `beebee.png`; link.href = canvas.toDataURL("image/png"); link.click();
    } else { captureGif(); }
};

async function captureGif() {
    statusTxt.style.display = 'block'; dBtn.disabled = true;
    try {
        const resp = await fetch('https://cdn.jsdelivr.net/gh/jnordberg/gif.js/dist/gif.worker.js');
        const workerUrl = URL.createObjectURL(new Blob([await resp.text()], { type: 'application/javascript' }));
        const gif = new GIF({ workers: 2, quality: 10, width: 720, height: 500, workerScript: workerUrl });
        
        // Ensure we are looping for the capture
        const originalLoopState = isLooping;
        isLooping = true;

        for (let i = 0; i < 30; i++) { 
            gif.addFrame(ctx, {copy: true, delay: 50}); 
            await new Promise(r => setTimeout(r, 50)); 
        }
        
        isLooping = originalLoopState; // Restore state

        gif.on('finished', (blob) => {
            const link = document.createElement('a'); link.href = URL.createObjectURL(blob); link.download = `beebee.gif`;
            document.body.appendChild(link); link.click(); document.body.removeChild(link);
            statusTxt.style.display = 'none'; dBtn.disabled = false;
        });
        gif.render();
    } catch(e) { statusTxt.style.display = 'none'; dBtn.disabled = false; }
}

if(!loadState()) populateSelects();
images['act1'].onload = () => requestAnimationFrame(mainLoop);
</script>
</body>
</html>
