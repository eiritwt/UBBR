<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Untitled Beebee Renderer</title>
    <script src="https://cdn.jsdelivr.net/gh/jnordberg/gif.js/dist/gif.js"></script>
    <style>
        body { background: #1a1a1a; color: white; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; margin: 0; padding: 10px; }
        .container { display: flex; flex-direction: column; gap: 12px; background: #222; padding: 15px; border-radius: 12px; width: 95%; max-width: 720px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        h2 { margin: 5px 0; font-size: 1.4em; color: #eee; text-align: center; }
        canvas { background: #333; border-radius: 8px; width: 100%; height: auto; border: 1px solid #444; }
        .controls { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .full-width { grid-column: span 2; }
        select, button { padding: 12px; background: #3d3d3d; color: white; border: 1px solid #555; border-radius: 8px; font-size: 14px; outline: none; }
        .active { background: #e74c3c; border-color: #ff7675; font-weight: bold; }
        .random-btn { background: #f39c12; border: none; font-weight: bold; color: #1a1a1a; }
        .download-btn { background: #27ae60; border: none; font-weight: bold; }
        .vibrate-btn { background: #9b59b6; border: none; font-weight: bold; }
        #status { font-size: 0.8em; color: #f1c40f; text-align: center; display: none; }
        label { font-size: 0.7em; color: #888; margin-top: 5px; font-weight: bold; text-transform: uppercase; }
        hr { border: 0; border-top: 1px solid #444; width: 100%; margin: 8px 0; }
    </style>
</head>
<body>

    <h2>Untitled Beebee Renderer</h2>

    <div class="container">
        <canvas id="beebeeCanvas" width="720" height="500"></canvas>
        <div id="status">Recording GIF... please wait.</div>
        
        <div class="controls">
            <label class="full-width">Character Version</label>
            <select id="actSelect" class="full-width">
                <option value="act1">Act 1: The Encounter</option>
                <option value="act2">Act 2: The Battle</option>
                <option value="act3">Act 3: The Fight</option>
            </select>

            <button id="randomBtn" class="full-width random-btn">Randomize Expression</button>
            <button id="vibeToggle" class="full-width vibrate-btn active">Vibration: ON</button>

            <hr class="full-width">

            <label class="full-width">Special Poses (*)</label>
            <select id="specialSelect" class="full-width"></select>

            <label class="full-width">Manual Mix</label>
            <select id="bodySelect"></select>
            <select id="mouthSelect"></select>
            <select id="eyesSelect" class="full-width"></select>

            <hr class="full-width">
            
            <button id="loopBtn" class="full-width">Start Animation Loop</button>
            <button id="mainDownloadBtn" class="full-width download-btn">Download PNG</button>
        </div>
    </div>

<script>
// [Acts Data Object remains the same as previous version]
const acts = {
    act1: { src: 'act1_beebee.png', grid: { width: 4, height: 8 }, anchor: { x: 546/2, y: 400/2 }, frames: ["body_normal","body_fear","body_point_crotch","body_point_heart","body_sing","mouth_normal","mouth_normal_talk","mouth_small","mouth_small_talk","mouth_small_lock","eyes_normal","eyes_normal_right","eyes_uncertain","eyes_uncertain_right","eyes_narrow","eyes_narrow_eyebrow","eyes_fear","eyes_pretty","eyes_wat","eyes_wat_2","body_panic*","body_panic_2*","body_scream_anger*","body_scream_anger_2*","body_scream*","body_scream_2*","body_flail*","body_flail2*","body_flail3*","body_flail4*","mouth_smile","mouth_smile_talk","mouth_smile_lock","eyes_smile","eyes_look","eyes_look_sad","eyes_look_sad_smile","eyes_pained1","eyes_pained2","mouth_shut","eyes_anger","body_meta*","body_laugh*","body_pride_talk*","body_pride*","body_squeeze_talk*","body_squeeze*"], loops: [{ trigger: "panic*", sequence: ["body_panic*", "body_panic_2*"], wait: 0.07 }, { trigger: "scream*", sequence: ["body_scream*", "body_scream_2*"], wait: 0.1 }, { trigger: "flail*", sequence: ["body_flail*", "body_flail2*", "body_flail3*", "body_flail4*"], wait: 0.05 }] },
    act2: { src: 'battle_bb.png', grid: { width: 10, height: 8 }, anchor: { x: 292.5, y: 249.4 }, frames: ["body_normal","body_two_up","body_chest","body_point","body_one_up","body_scream_a_1*","body_scream_a_2*","body_shocked*","mouth_small","mouth_small_talk","mouth_normal","mouth_normal_talk","mouth_smile","mouth_smile_talk","eyes_normal","eyes_normal_r","eyes_suspect","eyes_suspect_r","eyes_sad","eyes_sad_r","eyes_shock","eyes_happy","eyes_happy_r","eyes_closed","eyes_judge","body_judge_1","body_judge_2","body_scream_b_1*","body_scream_b_2*","body_scream_c_1*","body_scream_c_2*","body_cry_1*","body_cry_2*","body_cry_3*","body_cry_4","mouth_cry_talk","mouth_cry","eyes_cry","eyes_cry_2","body_cry_5*","body_cry_6","mouth_right","mouth_right_talk","eyes_cry_r_1","eyes_cry_r_2","eyes_cry_r_3","eyes_cry_r_4","mouth_blank","eyes_blank","eyes_asdf","eyes_angry","eyes_sad_2","eyes_wat","body_attacked*","body_frazzled","mouth_frazzled_talk","mouth_frazzled","eyes_frazzled","body_panicked","mouth_panicked","mouth_panicked_talk","eyes_panicked","body_special_a*","body_special_b_1*","body_special_b_2*","body_special_b_3*","body_special_c*","body_final_1*","body_final_2*","body_final_3*","body_final_4*","body_yell_1*","body_yell_2*","body_yell_angry_1*","body_yell_angry_2*"], loops: [{ trigger: "scream_c*", sequence: ["body_scream_c_1*", "body_scream_c_2*"], wait: 0.07 }, { trigger: "final*", sequence: ["body_final_1*", "body_final_2*", "body_final_3*", "body_final_4*"], wait: 0.05 }, { trigger: "special_b*", sequence: ["body_special_b_1*", "body_special_b_2*", "body_special_b_3*"], wait: 0.1 }] },
    act3: { src: 'fight_bb.png', grid: { width: 8, height: 3 }, anchor: { x: 270, y: 223 }, frames: ["body_normal_1","body_normal_2","body_normal_3","body_normal_4","mouth_sorry","mouth_sorry_talk","eyes_sorry_down","eyes_sorry","eyes_sorry_up","mouth_normal","mouth_normal_talk","eyes_oh_crap","eyes_start","eyes_normal","eyes_angry","eyes_sad","mouth_ignore","mouth_ignore_talk","eyes_ignore","eyes_ignore_oh_crap","body_attacked*","body_dead*","body_special_attack*"], loops: [] }
};

const canvas = document.getElementById('beebeeCanvas');
const ctx = canvas.getContext('2d');
let currentAct = 'act1';
const images = {};
let ticker = 0, lastTime = 0, animTimer = 0, animIndex = 0, isLooping = false, vibrateOn = true;

Object.keys(acts).forEach(k => { images[k] = new Image(); images[k].src = acts[k].src; });

const bSel = document.getElementById('bodySelect'), mSel = document.getElementById('mouthSelect'), eSel = document.getElementById('eyesSelect'), sSel = document.getElementById('specialSelect'), aSel = document.getElementById('actSelect'), lBtn = document.getElementById('loopBtn'), rBtn = document.getElementById('randomBtn'), vBtn = document.getElementById('vibeToggle'), dBtn = document.getElementById('mainDownloadBtn'), statusTxt = document.getElementById('status');

// [Core functions: populateSelects, updateSelectorsState, stopLoop remain largely same]
function populateSelects() {
    [bSel, mSel, eSel, sSel].forEach(s => s.innerHTML = '');
    const noneOpt = document.createElement('option'); noneOpt.value = 'none'; noneOpt.textContent = '-- Manual Mix --'; sSel.appendChild(noneOpt);
    acts[currentAct].frames.forEach(name => {
        const opt = document.createElement('option'); opt.value = name; opt.textContent = name;
        if (name.includes('*')) sSel.appendChild(opt); else if (name.startsWith('body')) bSel.appendChild(opt); else if (name.startsWith('mouth')) mSel.appendChild(opt); else if (name.startsWith('eyes')) eSel.appendChild(opt);
    });
    updateUI();
}

function updateUI() {
    const isSpecial = sSel.value !== 'none';
    [bSel, mSel, eSel].forEach(s => s.disabled = isSpecial);
    const hasLoop = acts[currentAct].loops.some(l => sSel.value.includes(l.trigger.replace('*','')));
    lBtn.style.display = (hasLoop || isLooping) ? 'block' : 'none';
    
    // Switch button text based on animation state
    if (vibrateOn || isLooping) {
        dBtn.textContent = "Download GIF";
        dBtn.className = "full-width vibrate-btn";
    } else {
        dBtn.textContent = "Download PNG";
        dBtn.className = "full-width download-btn";
    }
}

vBtn.onclick = () => { vibrateOn = !vibrateOn; vBtn.textContent = vibrateOn ? "Vibration: ON" : "Vibration: OFF"; vBtn.classList.toggle('active', vibrateOn); updateUI(); };

dBtn.onclick = () => {
    if (dBtn.textContent === "Download PNG") {
        const link = document.createElement('a');
        link.download = `beebee_${Date.now()}.png`;
        link.href = canvas.toDataURL("image/png");
        link.click();
    } else {
        captureGif();
    }
};

async function captureGif() {
    statusTxt.style.display = 'block';
    dBtn.disabled = true;

    // Create a worker for GIF.js (must be accessible via URL)
    const gif = new GIF({ workers: 2, quality: 10, width: 720, height: 500, workerScript: 'https://cdn.jsdelivr.net/gh/jnordberg/gif.js/dist/gif.worker.js' });

    // Capture 30 frames (approx 1 second of animation)
    for (let i = 0; i < 30; i++) {
        gif.addFrame(ctx, {copy: true, delay: 33});
        await new Promise(r => setTimeout(r, 33));
    }

    gif.on('finished', function(blob) {
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.download = `beebee_anim_${Date.now()}.gif`;
        link.href = url;
        link.click();
        statusTxt.style.display = 'none';
        dBtn.disabled = false;
    });

    gif.render();
}

// [Rest of logic for drawing and main loop same as before]
aSel.onchange = (e) => { currentAct = e.target.value; populateSelects(); };
sSel.onchange = () => { updateUI(); };
lBtn.onclick = () => { isLooping = !isLooping; lBtn.classList.toggle('active', isLooping); updateUI(); };
rBtn.onclick = () => { sSel.value = 'none'; bSel.selectedIndex = Math.floor(Math.random()*bSel.options.length); mSel.selectedIndex = Math.floor(Math.random()*mSel.options.length); eSel.selectedIndex = Math.floor(Math.random()*eSel.options.length); updateUI(); };

function drawLayer(name) {
    const act = acts[currentAct];
    const idx = act.frames.indexOf(name);
    if (idx === -1) return;
    const col = idx % act.grid.width, row = Math.floor(idx / act.grid.width);
    ctx.drawImage(images[currentAct], col*720, row*500, 720, 500, -act.anchor.x, -act.anchor.y, 720, 500);
}

function mainLoop(time) {
    const delta = (time - lastTime) / 1000;
    lastTime = time; ticker += delta;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save(); ctx.translate(canvas.width / 2, canvas.height / 2);
    let squash = (vibrateOn) ? 1 + Math.sin(ticker * Math.PI * 2 * 7) * 0.01 : 1;
    let frameToDraw = sSel.value;
    if (isLooping) {
        const loop = acts[currentAct].loops.find(l => sSel.value.includes(l.trigger.replace('*','')));
        if (loop) { animTimer += delta; if (animTimer >= loop.wait) { animIndex = (animIndex + 1) % loop.sequence.length; animTimer = 0; } frameToDraw = loop.sequence[animIndex]; }
    }
    ctx.scale(1, squash);
    if (frameToDraw !== 'none') drawLayer(frameToDraw);
    else { drawLayer(bSel.value); drawLayer(mSel.value); drawLayer(eSel.value); }
    ctx.restore();
    requestAnimationFrame(mainLoop);
}
populateSelects();
images['act1'].onload = () => requestAnimationFrame(mainLoop);
</script>
</body>
</html>
